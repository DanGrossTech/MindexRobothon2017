#pragma config(StandardModel, "RVW Buggybot")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Movement.h"
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Swing Turns

This program instructs your robot to make a swing turn right for 0.75 seconds, wait for 1 second and then
make a swing turn left for 0.75 seconds.  There is a two second pause at the beginning of the program.

Robot Model(s): NXT REMBOT

[I/O Port]          [Name]              [Type]                [Description]
Motor Port B        rightMotor          NXT Motor             Right side motor
Motor Port C        leftMotor           NXT Motor             Left side motor


----------------------------------------------------------------------------------------------------*/

/**
point the bot
*/
void best_path(bool right) {
	char str[80];
	int distance = 0;
	int last_distance = 0;
	int degrees_turned = 0;
	int slop = 10;
	bool search = true;
	while ( search ) {
		last_distance = SensorValue[sonar];
		if ( right ) {
		turn_right(5);
	} else {
	  turn_left(5);
	}
		distance  = SensorValue[sonar];   // update to new distance from object
		sprintf(str, "1sonar %d degrees %d distance %d %d\n", SensorValue[sonar], degrees_turned, distance, last_distance);
			debug_print(str);
			degrees_turned++;
		if ( distance <= last_distance + slop ) {

		}
		else {
			search = false;
		}
	}

}

void best_path2(bool right) {
	char str[80];
	int distance = 0;
	int last_distance = 0;
	int degrees_turned = 0;
	int slop = 0;
	bool search = true;
	int i;
	for (  i = 0; i < 90; i++ ) {
		last_distance = SensorValue[sonar];
		if ( right ) {
			turn_right(5);
			} else {
			turn_left(5);
		}

		if ( SensorValue[sonar] > last_distance ) {
			distance = SensorValue[sonar];
			degrees_turned = i;
		}
		sprintf(str, "1sonar %d degrees %d distance %d %d\n", SensorValue[sonar], degrees_turned, distance, last_distance);
		debug_print(str);
	}

		for (  i = 90; i > degrees; i-- ) {
					sprintf(str, "1sonar %d degrees  %d %d\n", SensorValue[sonar], degrees, i);
		debug_print(str);

		if ( right ) {
			back_left(5);
			} else {
			back_right(5);
		}
	}


}

void forward_till_obs() {
	bool forward = true;
		char str[80];
int threshold = 15;
	while (true)
  {

      if (SensorValue[sonar] >= threshold) {
      	sprintf(str, "sensor %d greater\n ", SensorValue[sonar]);
      	 debug_print(str);

      	go_straight(FULL_SPEED, 1);
      	stop_movement(2);
    } else {
       forward = false;
     }

    }
}



void detectwall () {
	bool step1 = false;
	bool step2 = false;
	bool step3= false;
	char str[80];
int threshold = 15;

best_path(true);   // get out of box


forward_till_obs();




 while (true)
  {
    //Make sure the value is not an error.
    {
      if (SensorValue[sonar] >= threshold) {
      	sprintf(str, "sensor %d greater\n ", SensorValue[sonar]);
      	 debug_print(str);

      	go_straight(FULL_SPEED, 1);
      	stop_movement(2);

      } else if (SensorValue[sonar] < threshold) {
          sprintf(str, "sensor %d less than \n", SensorValue[sonar]);
          debug_print(str);

       best_path(false);

      } else {
        debug_print("unknown");
      }
    }
  }
}


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	// wait1Msec(2000);						// Robot waits for 2000 milliseconds before executing program

	debug_print("My name is Johnny Five");

	wait1Msec(2000);						// Robot waits for 2000 milliseconds before executing program

	detectwall();

	// Turn Right at full power for 0.75 seconds

	turn_right(90);

	wait1Msec(2000);

	turn_left(180);

	wait1Msec(2000);

	go_straight(FULL_SPEED, 2000);

	stop_movement(1000);
}




// Program ends, and the robot stops
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
